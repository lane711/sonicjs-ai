export const metadata = {
  title: 'Collections - SonicJS',
  description:
    'Define content types with TypeScript schemas, field validation, and automatic API generation. Learn how to create custom collections in SonicJS.',
}

export const sections = [
  { title: 'Overview', id: 'overview' },
  { title: 'Creating Collections', id: 'creating-collections' },
  { title: 'Field Types', id: 'field-types' },
  { title: 'Validation', id: 'validation' },
  { title: 'Examples', id: 'examples' },
]

# Collections

Define content types with TypeScript schemas and field validation. Collections are the foundation of your content model in SonicJS. {{ className: 'lead' }}

## Overview

Collections define your content types using TypeScript schemas. Each collection automatically gets:

- Type-safe database schema
- Automatic API endpoints
- Admin UI for content management
- Field validation and constraints
- Version control through git

### Two Types of Collections

**Config-Managed Collections:**
- Defined in TypeScript files (`src/collections/*.collection.ts`)
- Version controlled with your codebase
- Automatically synced on app startup
- Locked from editing in the admin UI (marked with "Config" badge)
- Type-safe with IDE autocomplete

**UI-Created Collections:**
- Created and edited through the admin interface
- Stored directly in the database
- Not version controlled
- Fully editable in the UI
- Great for rapid prototyping

---

## Creating Collections

### Basic Collection

Create a new file in `src/collections/` with a `.collection.ts` extension:

<CodeGroup title="Blog Posts Collection">

```typescript
// src/collections/blog-posts.collection.ts
import { CollectionConfig } from '../types/collection-config'

export const blogPostsCollection: CollectionConfig = {
  name: 'blog_posts',
  displayName: 'Blog Posts',
  description: 'Articles and blog content',
  schema: {
    type: 'object',
    properties: {
      title: {
        type: 'string',
        required: true,
        minLength: 3,
        maxLength: 200
      },
      slug: {
        type: 'slug',
        required: true
      },
      content: {
        type: 'richtext',
        required: true
      },
      excerpt: {
        type: 'textarea',
        maxLength: 500
      },
      author: {
        type: 'reference',
        collection: 'users',
        required: true
      },
      publishDate: {
        type: 'datetime',
        required: true
      },
      status: {
        type: 'select',
        enum: ['draft', 'published', 'archived'],
        default: 'draft'
      }
    }
  },
  icon: 'üìù',
  color: 'blue',
  managed: true,
  isActive: true,
  defaultSort: 'created_at',
  defaultSortOrder: 'desc',
  listFields: ['title', 'author', 'publishDate', 'status'],
  searchFields: ['title', 'excerpt', 'content']
}
```

</CodeGroup>

### Syncing Collections

Collections are automatically synced on server startup. You can also manually sync:

<CodeGroup title="Sync Collections">

```bash
# Collections auto-sync on server restart
npm run dev

# Or manually sync
npm run sync-collections
```

</CodeGroup>

---

## Field Types

SonicJS supports 30+ field types for building rich content schemas:

### Text Fields

<Properties>
  <Property name="string" type="string">
    Single-line text input. Use for titles, names, short text.
  </Property>
  <Property name="textarea" type="string">
    Multi-line plain text. Use for descriptions, notes, long text.
  </Property>
  <Property name="email" type="string">
    Email with validation. Use for contact emails, author info.
  </Property>
  <Property name="url" type="string">
    URL with validation. Use for links, external resources.
  </Property>
  <Property name="slug" type="string">
    URL-friendly identifier. Use for page URLs, SEO paths.
  </Property>
  <Property name="color" type="string">
    Color picker. Use for theme colors, UI customization.
  </Property>
</Properties>

### Rich Content

<Properties>
  <Property name="richtext" type="string">
    WYSIWYG HTML editor. Use for blog posts, articles, formatted content.
  </Property>
  <Property name="markdown" type="string">
    Markdown editor. Use for documentation, technical content.
  </Property>
  <Property name="json" type="object">
    JSON editor. Use for structured data, API responses.
  </Property>
</Properties>

### Numbers and Dates

<Properties>
  <Property name="number" type="number">
    Numeric input. Use for prices, quantities, ratings.
  </Property>
  <Property name="date" type="string">
    Date picker (no time). Use for birthdays, deadlines.
  </Property>
  <Property name="datetime" type="string">
    Date and time picker. Use for publish dates, events.
  </Property>
</Properties>

### Selections

<Properties>
  <Property name="select" type="string">
    Dropdown (single choice). Use for categories, status fields.
  </Property>
  <Property name="multiselect" type="array">
    Dropdown (multiple choices). Use for tags, multiple categories.
  </Property>
  <Property name="radio" type="string">
    Radio buttons. Use for status, visibility options.
  </Property>
  <Property name="checkbox" type="boolean">
    Boolean checkbox. Use for feature toggles, flags.
  </Property>
</Properties>

### Media and Files

<Properties>
  <Property name="media" type="string">
    Image/media picker. Use for featured images, avatars.
  </Property>
  <Property name="file" type="string">
    File upload. Use for PDFs, documents, downloads.
  </Property>
</Properties>

### Relationships

<Properties>
  <Property name="reference" type="string">
    Reference to another collection. Use for authors, categories.
  </Property>
  <Property name="array" type="array">
    Array of items. Can contain any field type.
  </Property>
</Properties>

---

## Validation

### Built-in Validators

<CodeGroup title="Field Validation">

```typescript
export const productsCollection: CollectionConfig = {
  name: 'products',
  displayName: 'Products',
  schema: {
    type: 'object',
    properties: {
      name: {
        type: 'string',
        required: true,
        minLength: 3,
        maxLength: 200
      },
      sku: {
        type: 'string',
        required: true,
        pattern: '^[A-Z0-9-]+$'  // Only uppercase, numbers, hyphens
      },
      price: {
        type: 'number',
        required: true,
        minimum: 0,
        maximum: 999999
      },
      email: {
        type: 'email',
        required: true
      },
      url: {
        type: 'url',
        required: false
      },
      status: {
        type: 'select',
        enum: ['draft', 'active', 'archived'],
        default: 'draft'
      }
    }
  },
  managed: true,
  isActive: true
}
```

</CodeGroup>

### Validation Rules

- **required** - Field must have a value
- **minLength** / **maxLength** - String length constraints
- **minimum** / **maximum** - Number range constraints
- **pattern** - Regular expression validation
- **enum** - Must be one of specified values
- **default** - Default value if not provided

---

## Examples

### E-commerce Product

<CodeGroup title="Product Collection">

```typescript
export const productsCollection: CollectionConfig = {
  name: 'products',
  displayName: 'Products',
  description: 'E-commerce product catalog',
  schema: {
    type: 'object',
    properties: {
      name: {
        type: 'string',
        required: true
      },
      sku: {
        type: 'string',
        required: true
      },
      price: {
        type: 'number',
        required: true,
        minimum: 0
      },
      description: {
        type: 'richtext'
      },
      images: {
        type: 'array',
        items: {
          type: 'media',
          accept: 'image/*'
        }
      },
      category: {
        type: 'select',
        enum: ['electronics', 'clothing', 'home', 'sports']
      },
      inStock: {
        type: 'boolean',
        default: true
      },
      tags: {
        type: 'array',
        items: { type: 'string' }
      }
    }
  },
  icon: 'üõçÔ∏è',
  managed: true,
  isActive: true
}
```

</CodeGroup>

### Documentation Page

<CodeGroup title="Docs Collection">

```typescript
export const docsCollection: CollectionConfig = {
  name: 'documentation',
  displayName: 'Documentation',
  schema: {
    type: 'object',
    properties: {
      title: {
        type: 'string',
        required: true
      },
      slug: {
        type: 'slug',
        required: true
      },
      content: {
        type: 'markdown',
        required: true
      },
      category: {
        type: 'select',
        enum: ['getting-started', 'api', 'guides', 'reference']
      },
      order: {
        type: 'number',
        default: 0
      },
      published: {
        type: 'boolean',
        default: false
      }
    }
  },
  icon: 'üìö',
  managed: true,
  isActive: true
}
```

</CodeGroup>

### Event Management

<CodeGroup title="Events Collection">

```typescript
export const eventsCollection: CollectionConfig = {
  name: 'events',
  displayName: 'Events',
  schema: {
    type: 'object',
    properties: {
      title: {
        type: 'string',
        required: true
      },
      description: {
        type: 'richtext'
      },
      startDate: {
        type: 'datetime',
        required: true
      },
      endDate: {
        type: 'datetime',
        required: true
      },
      location: {
        type: 'string'
      },
      virtualLink: {
        type: 'url'
      },
      capacity: {
        type: 'number',
        minimum: 1
      },
      registration: {
        type: 'boolean',
        default: false
      },
      organizer: {
        type: 'reference',
        collection: 'users'
      }
    }
  },
  icon: 'üìÖ',
  managed: true,
  isActive: true
}
```

</CodeGroup>

---

## Using Collections

### Query Content

<CodeGroup title="Fetch Collection Content">

```typescript
// Get all content from a collection
const posts = await db.select()
  .from(content)
  .where(eq(content.collection_id, 'blog_posts'))
  .orderBy(desc(content.created_at))
  .limit(10)

// Get single content item
const post = await db.select()
  .from(content)
  .where(eq(content.id, postId))
  .get()

// Search content
const results = await db.select()
  .from(content)
  .where(
    and(
      eq(content.collection_id, 'blog_posts'),
      like(content.title, '%search%')
    )
  )
  .all()
```

</CodeGroup>

### API Endpoints

Collections automatically get REST API endpoints:

<ApiEndpoint method="GET" path="/api/collections/{collection}/content" description="Get all content from a collection" auth={false} />

<ApiEndpoint method="GET" path="/api/content/{id}" description="Get single content item" auth={false} />

<ApiEndpoint method="POST" path="/admin/content" description="Create new content" auth={true} />

<ApiEndpoint method="PUT" path="/admin/content/{id}" description="Update content" auth={true} />

<ApiEndpoint method="DELETE" path="/admin/content/{id}" description="Delete content" auth={true} />

---

## Best Practices

<Callout type="tip" title="Collection Design Tips">
- Use descriptive field names that reflect your content model
- Set appropriate validation rules to maintain data quality
- Use references for relationships between collections
- Enable search on fields that users will query frequently
- Set reasonable defaults for optional fields
</Callout>

<Callout type="warning" title="Performance Considerations">
- Limit the number of fields in `listFields` to improve list performance
- Use appropriate field types (e.g., `select` instead of `string` for fixed options)
- Index frequently queried fields in your database
</Callout>

---

## Next Steps

<div className="not-prose">
  <Button href="/api" variant="text" arrow="right">
    <>Explore the API reference</>
  </Button>
</div>

<div className="not-prose mt-4">
  <Button href="/database" variant="text" arrow="right">
    <>Learn about database management</>
  </Button>
</div>
