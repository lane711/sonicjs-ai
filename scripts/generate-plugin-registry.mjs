#!/usr/bin/env node
/**
 * Plugin Registry Generator
 *
 * This script scans the src/plugins directory for all manifest.json files
 * and generates a TypeScript file (plugin-registry.ts) that exports all
 * plugin manifests as a typed registry.
 *
 * This allows us to:
 * 1. Have a single source of truth (manifest.json files)
 * 2. Auto-discover plugins at build time
 * 3. Work with Cloudflare Workers (no runtime filesystem access)
 *
 * Run: node scripts/generate-plugin-registry.mjs
 */

import { readdir, readFile, writeFile } from 'fs/promises'
import { join, dirname } from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)
const PROJECT_ROOT = join(__dirname, '..')
const PLUGINS_DIR = join(PROJECT_ROOT, 'src/plugins')
const OUTPUT_FILE = join(PROJECT_ROOT, 'src/plugins/plugin-registry.ts')

/**
 * Recursively find all manifest.json files
 */
async function findManifests(dir, manifests = []) {
  try {
    const entries = await readdir(dir, { withFileTypes: true })

    for (const entry of entries) {
      const fullPath = join(dir, entry.name)

      if (entry.isDirectory()) {
        // Skip node_modules and hidden directories
        if (!entry.name.startsWith('.') && entry.name !== 'node_modules') {
          await findManifests(fullPath, manifests)
        }
      } else if (entry.name === 'manifest.json') {
        manifests.push(fullPath)
      }
    }
  } catch (error) {
    console.error(`Error reading directory ${dir}:`, error.message)
  }

  return manifests
}

/**
 * Load and validate a manifest file
 */
async function loadManifest(manifestPath) {
  try {
    const content = await readFile(manifestPath, 'utf-8')
    const manifest = JSON.parse(content)

    // Validate required fields
    if (!manifest.id) {
      console.warn(`‚ö†Ô∏è  Manifest at ${manifestPath} is missing 'id' field`)
      return null
    }

    return {
      path: manifestPath,
      manifest
    }
  } catch (error) {
    console.error(`‚ùå Error loading manifest ${manifestPath}:`, error.message)
    return null
  }
}

/**
 * Generate TypeScript plugin registry file
 */
function generateRegistryFile(manifests) {
  const timestamp = new Date().toISOString()

  // Generate the registry object
  const registryEntries = manifests
    .map(({ manifest }) => {
      const id = manifest.id
      const manifestJson = JSON.stringify(manifest, null, 2)
        .split('\n')
        .map((line, i) => i === 0 ? line : `  ${line}`)
        .join('\n')

      return `  '${id}': ${manifestJson}`
    })
    .join(',\n\n')

  // Generate TypeScript file
  return `/**
 * Plugin Registry
 *
 * This file is AUTO-GENERATED by scripts/generate-plugin-registry.mjs
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * Generated: ${timestamp}
 * Source: All manifest.json files in src/plugins/
 */

export interface PluginManifest {
  id: string
  name: string
  version: string
  description: string
  author: string
  homepage?: string
  repository?: string
  license?: string
  category: string
  tags?: string[]
  dependencies?: string[]
  settings?: Record<string, any>
  hooks?: Record<string, string>
  routes?: Array<{
    path: string
    method: string
    handler: string
    description?: string
  }>
  permissions?: Record<string, string>
  adminMenu?: {
    label: string
    icon: string
    path: string
    order: number
  }
}

/**
 * Plugin Registry
 * Maps plugin ID to its manifest
 */
export const PLUGIN_REGISTRY: Record<string, PluginManifest> = {
${registryEntries}
} as const

/**
 * Get all plugin IDs
 */
export const PLUGIN_IDS = Object.keys(PLUGIN_REGISTRY) as ReadonlyArray<string>

/**
 * Get all core plugin IDs (plugins with is_core flag or in core directories)
 */
export const CORE_PLUGIN_IDS = PLUGIN_IDS.filter(id => {
  const manifest = PLUGIN_REGISTRY[id]
  return id.startsWith('core-') || id === 'design' || id === 'database-tools' || id === 'hello-world'
}) as ReadonlyArray<string>

/**
 * Get plugin manifest by ID
 */
export function getPluginManifest(id: string): PluginManifest | undefined {
  return PLUGIN_REGISTRY[id]
}

/**
 * Check if a plugin exists
 */
export function hasPlugin(id: string): boolean {
  return id in PLUGIN_REGISTRY
}

/**
 * Get all plugins by category
 */
export function getPluginsByCategory(category: string): PluginManifest[] {
  return PLUGIN_IDS
    .map(id => PLUGIN_REGISTRY[id])
    .filter((manifest): manifest is PluginManifest => manifest !== undefined && manifest.category === category)
}
`
}

/**
 * Main execution
 */
async function main() {
  console.log('üîç Discovering plugins...\n')

  // Find all manifest.json files
  const manifestPaths = await findManifests(PLUGINS_DIR)
  console.log(`Found ${manifestPaths.length} manifest.json files:\n`)

  // Load all manifests
  const loadedManifests = []
  for (const path of manifestPaths) {
    const result = await loadManifest(path)
    if (result) {
      loadedManifests.push(result)
      console.log(`  ‚úì ${result.manifest.id} (${result.manifest.name})`)
    }
  }

  console.log(`\n‚úÖ Loaded ${loadedManifests.length} valid manifests\n`)

  // Generate registry file
  const registryContent = generateRegistryFile(loadedManifests)
  await writeFile(OUTPUT_FILE, registryContent, 'utf-8')

  console.log(`üìù Generated plugin registry: ${OUTPUT_FILE}`)
  console.log(`\n‚ú® Plugin registry successfully generated!\n`)

  // Print summary
  console.log('Summary:')
  console.log(`  - Total plugins: ${loadedManifests.length}`)
  console.log(`  - Registry file: src/plugins/plugin-registry.ts`)
  console.log(`  - Core plugins: ${loadedManifests.filter(m => m.manifest.id.startsWith('core-')).length}`)
  console.log('')
}

main().catch(error => {
  console.error('‚ùå Fatal error:', error)
  process.exit(1)
})
